import { createRunner, parse, PuppeteerRunnerExtension } from '@puppeteer/replay';
import puppeteer from 'puppeteer';
import fs from 'fs';

// Define the max execution time for script
const TIMEOUT = 10000;

// Override the Runner to support customized process within steps
class MyRunner extends PuppeteerRunnerExtension {
  async beforeAllSteps(flow) {
    await super.beforeAllSteps(flow);
    Object.values(flow.steps).forEach((row) => {
      if (row.type === 'navigate' && !row.hasOwnProperty('timeout')) {
        row.timeout = TIMEOUT;
      };
    });
  }
}

(async () => {
  // Fetch recording script generated by Chrome Recorder
  const recordingText = fs.readFileSync('./script_samples/recording.json', 'utf8');
  const recording = parse(JSON.parse(recordingText));

  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Collect request events
  const result = [];
  page.on('requestfinished', (request) => {
    const information = {
      url: request.url(),
      method: request.method(),
      payload: request.postData()
    };
    result.push(information);
  });

  // Execute
  const runner = await createRunner(
    recording,
    new MyRunner(browser, page)
  );
  await runner.run();
  await browser.close();

  console.log("Done.");
  console.log(result);
})()
